{"version":3,"file":"smart-array-filter.min.js","sources":["../node_modules/lodash.escaperegexp/index.js","../src/getCheckNumber.js","../src/getCheckString.js","../src/parseKeywords.js","../src/index.js"],"sourcesContent":["/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n */\nfunction escapeRegExp(string) {\n  string = toString(string);\n  return (string && reHasRegExpChar.test(string))\n    ? string.replace(reRegExpChar, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n","const operators = {\n  '<': (query) => {\n    return function (number) {\n      return number < query;\n    };\n  },\n  '<=': (query) => {\n    return function (number) {\n      return number <= query;\n    };\n  },\n  '=': (query) => {\n    return function (number) {\n      return number === query;\n    };\n  },\n  '>=': (query) => {\n    return function (number) {\n      return number >= query;\n    };\n  },\n  '>': (query) => {\n    return function (number) {\n      return number > query;\n    };\n  },\n};\n\n// we also deal with ..10 and 10..\noperators['..'] = operators['<='];\n\nexport default function getCheckNumber(keyword) {\n  let match = /^\\s*\\(?\\s*(<|<=|=|>=|>|\\.\\.)?(-?\\d*\\.?\\d+)(?:(\\.\\.)(-?\\d*\\.?\\d*))?\\s*\\)?\\s*$/.exec(\n    keyword,\n  );\n  let checkNumber = () => false;\n  if (match) {\n    let operator = match[1];\n    let query = parseFloat(match[2]);\n    let dots = match[3];\n    let secondQuery = match[4];\n    if (operator) {\n      checkNumber = operators[operator](query);\n    } else if (dots) {\n      if (secondQuery !== '') {\n        secondQuery = parseFloat(secondQuery);\n        checkNumber = function (number) {\n          return query <= number && number <= secondQuery;\n        };\n      } else {\n        checkNumber = operators['>='](query);\n      }\n    } else {\n      checkNumber = operators['='](query);\n    }\n  }\n  return checkNumber;\n}\n","import escapeRegExp from 'lodash.escaperegexp';\n\nconst operators = {\n  '<': (query) => {\n    return function (string) {\n      return string < query;\n    };\n  },\n  '<=': (query) => {\n    return function (string) {\n      return string <= query;\n    };\n  },\n  '=': (query, insensitive) => {\n    query = `^${escapeRegExp(query)}$`;\n    const reg = new RegExp(query, insensitive);\n\n    return function (string) {\n      return reg.test(string);\n    };\n  },\n  '~': (query, insensitive) => {\n    query = escapeRegExp(query);\n    const reg = new RegExp(query, insensitive);\n\n    return function (string) {\n      return reg.test(string);\n    };\n  },\n  '>=': (query) => {\n    return function (string) {\n      return string >= query;\n    };\n  },\n  '>': (query) => {\n    return function (string) {\n      return string > query;\n    };\n  },\n};\n\noperators['..'] = operators['<='];\n\nexport default function getCheckString(keyword, insensitive) {\n  let parts = keyword.split('..');\n  let match = /^\\s*\\(?\\s*(<|<=|=|>=|>)?(\\S*)\\s*\\)?$/.exec(parts[0]);\n  let checkString = () => false;\n  if (match) {\n    let operator = match[1];\n    let query = match[2];\n    let dots = parts.length > 1 ? '..' : '';\n    let secondQuery = parts[1];\n    if (operator) {\n      checkString = operators[operator](query, insensitive);\n    } else if (dots) {\n      if (secondQuery !== '') {\n        checkString = function (string) {\n          return query <= string && string <= secondQuery;\n        };\n      } else {\n        checkString = operators['>='](query, insensitive);\n      }\n    } else {\n      checkString = operators['~'](query, insensitive);\n    }\n  }\n  return checkString;\n}\n","let separators = /[ ;,\\t\\r\\n]/;\n\nexport default function parseKeywords(keywords) {\n  let result = [];\n  let inQuotes = false;\n  let inSeparator = true;\n  let currentWord = [];\n  let previous = '';\n  for (let i = 0; i < keywords.length; i++) {\n    let current = keywords.charAt(i);\n    if (inQuotes) {\n      if (previous === '\"') {\n        // escaped quote\n        if (current === '\"') {\n          previous = '';\n          continue;\n        }\n        // end of quoted part\n        currentWord.pop(); // remove last quote that was added\n        inQuotes = false;\n        i--;\n        continue;\n      }\n      currentWord.push(current);\n      previous = current;\n      continue;\n    }\n    if (inSeparator) {\n      // still in separator ?\n      if (separators.test(current)) {\n        previous = current;\n        continue;\n      }\n      inSeparator = false;\n    }\n    // start of quoted part\n    if (current === '\"') {\n      inQuotes = true;\n      previous = '';\n      continue;\n    }\n    // start of separator part\n    if (separators.test(current)) {\n      if (currentWord.length) result.push(currentWord.join(''));\n      currentWord = [];\n      inSeparator = true;\n      continue;\n    }\n    currentWord.push(current);\n    previous = '';\n  }\n\n  if (previous === '\"') currentWord.pop();\n  if (currentWord.length) result.push(currentWord.join(''));\n\n  return result;\n}\n","import escapeRegExp from 'lodash.escaperegexp';\n\nimport getCheckNumber from './getCheckNumber';\nimport getCheckString from './getCheckString';\nimport parseKeywords from './parseKeywords';\n\n/**\n *\n * @param {Array} array\n * @param {object} [options={}]\n * @param {number} [options.limit=Infinity]\n * @param {boolean} [options.caseSensitive=false]\n * @param {string|Array} [options.keywords=[]]\n * @param {boolean} [options.index=false] Returns the indices in the array that match\n * @param {boolean} [options.predicate='AND'] Could be either AND or OR\n */\nexport function filter(array, options = {}) {\n  let result = [];\n\n  let { index = false, predicate = 'AND' } = options;\n\n  let limit = options.limit ? options.limit : Infinity;\n\n  let keywords = options.keywords || [];\n\n  let insensitive = options.caseSensitive ? '' : 'i';\n  if (typeof keywords === 'string') {\n    keywords = parseKeywords(keywords);\n  }\n  keywords = keywords.map(function (keyword) {\n    let criterion = {\n      is: false,\n      key: false,\n      negate: false,\n      valueReg: undefined,\n    };\n\n    if (keyword.charAt(0) === '-') {\n      criterion.negate = true;\n      keyword = keyword.substring(1);\n    }\n    let colon = keyword.indexOf(':');\n    if (colon > -1) {\n      let value = keyword.substring(colon + 1);\n      if (colon > 0) {\n        let key = keyword.substring(0, colon);\n        if (key === 'is') {\n          // a property path exists\n          criterion.is = new RegExp(\n            `(^|\\\\.)${escapeRegExp(value)}(\\\\.|$)`,\n            insensitive,\n          );\n        }\n        criterion.key = new RegExp(\n          `(^|\\\\.)${escapeRegExp(key)}(\\\\.|$)`,\n          insensitive,\n        );\n      }\n      fillCriterion(criterion, value, insensitive);\n    } else {\n      fillCriterion(criterion, keyword, insensitive);\n    }\n\n    return criterion;\n  });\n\n  let matched = 0;\n  for (let i = 0; i < array.length && matched < limit; i++) {\n    if (match(array[i], keywords, predicate)) {\n      matched = result.push(index ? i : array[i]);\n    }\n  }\n  return result;\n}\n\nfunction fillCriterion(criterion, keyword, insensitive) {\n  criterion.checkString = getCheckString(keyword, insensitive);\n  criterion.checkNumber = getCheckNumber(keyword);\n}\n\nexport function match(element, keywords, predicate) {\n  if (keywords.length) {\n    let found = false;\n    for (let i = 0; i < keywords.length; i++) {\n      // match XOR negate\n      if (\n        recursiveMatch(element, keywords[i], [])\n          ? !keywords[i].negate\n          : keywords[i].negate\n      ) {\n        if (predicate === 'OR') {\n          return true;\n        }\n        found = true;\n      } else if (predicate === 'AND') {\n        return false;\n      }\n    }\n    return found;\n  }\n  return true;\n}\n\nfunction recursiveMatch(element, keyword, keys) {\n  if (typeof element === 'object') {\n    if (Array.isArray(element)) {\n      for (let i = 0; i < element.length; i++) {\n        if (recursiveMatch(element[i], keyword, keys)) {\n          return true;\n        }\n      }\n    } else {\n      for (let i in element) {\n        keys.push(i);\n        let didMatch = recursiveMatch(element[i], keyword, keys);\n        keys.pop();\n        if (didMatch) return true;\n      }\n    }\n  } else if (keyword.is) {\n    // we check for the presence of a key (jpath)\n    if (keyword.is.test(keys.join('.'))) {\n      return !!element;\n    } else {\n      return false;\n    }\n  } else {\n    // need to check if keys match\n    if (keyword.key && !keyword.key.test(keys.join('.'))) return false;\n    //if (key && keyword.key && key !== keyword.key) return false;\n    return nativeMatch(element, keyword);\n  }\n}\n\nfunction nativeMatch(element, keyword) {\n  if (typeof element === 'string') {\n    return keyword.checkString(element);\n  } else if (typeof element === 'number') {\n    return keyword.checkNumber(element);\n  } else {\n    return false;\n  }\n}\n"],"names":["symbolTag","reRegExpChar","reHasRegExpChar","RegExp","source","freeGlobal","global","Object","freeSelf","self","root","Function","objectToString","prototype","toString","Symbol","symbolProto","undefined","symbolToString","baseToString","value","isObjectLike","call","isSymbol","result","string","test","replace","operators","query","number","insensitive","escapeRegExp","reg","separators","fillCriterion","criterion","keyword","checkString","parts","split","match","exec","operator","dots","length","secondQuery","getCheckString","checkNumber","parseFloat","getCheckNumber","element","keywords","predicate","found","i","recursiveMatch","negate","keys","is","join","key","nativeMatch","Array","isArray","push","didMatch","pop","array","options","index","limit","Infinity","caseSensitive","inQuotes","inSeparator","currentWord","previous","current","charAt","parseKeywords","map","valueReg","substring","colon","indexOf","matched"],"mappings":"6YAaIA,EAAY,kBAMZC,EAAe,sBACfC,EAAkBC,OAAOF,EAAaG,QAGtCC,EAA8B,iBAAVC,GAAsBA,GAAUA,EAAOC,SAAWA,QAAUD,EAGhFE,EAA0B,iBAARC,MAAoBA,MAAQA,KAAKF,SAAWA,QAAUE,KAGxEC,EAAOL,GAAcG,GAAYG,SAAS,cAATA,GAUjCC,EAPcL,OAAOM,UAOQC,SAG7BC,EAASL,EAAKK,OAGdC,EAAcD,EAASA,EAAOF,eAAYI,EAC1CC,EAAiBF,EAAcA,EAAYF,cAAWG,EAU1D,SAASE,EAAaC,MAEA,iBAATA,SACFA,KAsDX,SAAkBA,SACO,iBAATA,GAtBhB,SAAsBA,WACXA,GAAyB,iBAATA,EAsBtBC,CAAaD,IAAUR,EAAeU,KAAKF,IAAUpB,EAtDpDuB,CAASH,UACJF,EAAiBA,EAAeI,KAAKF,GAAS,OAEnDI,EAAUJ,EAAQ,SACJ,KAAVI,GAAkB,EAAIJ,IAvDjB,SAuDwC,KAAOI,EAoG9D,MAPA,SAAsBC,GAnBtB,IAAkBL,SAoBhBK,EAnBgB,OADAL,EAoBEK,GAnBK,GAAKN,EAAaC,KAoBvBlB,EAAgBwB,KAAKD,GACnCA,EAAOE,QAAQ1B,EAAc,QAC7BwB,GClKN,MAAMG,EAAY,KACVC,GACG,SAAUC,UACRA,EAASD,QAGbA,GACE,SAAUC,UACRA,GAAUD,OAGfA,GACG,SAAUC,UACRA,IAAWD,QAGfA,GACE,SAAUC,UACRA,GAAUD,OAGfA,GACG,SAAUC,UACRA,EAASD,IAMtBD,EAAU,MAAQA,EAAU,MC3B5B,MAAMA,EAAY,KACVC,GACG,SAAUJ,UACRA,EAASI,QAGbA,GACE,SAAUJ,UACRA,GAAUI,OAGhB,CAACA,EAAOE,KACXF,EAAS,IAAGG,EAAaH,YACnBI,EAAM,IAAI9B,OAAO0B,EAAOE,UAEvB,SAAUN,UACRQ,EAAIP,KAAKD,SAGf,CAACI,EAAOE,KACXF,EAAQG,EAAaH,SACfI,EAAM,IAAI9B,OAAO0B,EAAOE,UAEvB,SAAUN,UACRQ,EAAIP,KAAKD,UAGbI,GACE,SAAUJ,UACRA,GAAUI,OAGfA,GACG,SAAUJ,UACRA,EAASI,MAKZ,MAAQD,EAAU,MCzC5B,IAAIM,EAAa,cC2EjB,SAASC,EAAcC,EAAWC,EAASN,GACzCK,EAAUE,YFjCG,SAAwBD,EAASN,OAC1CQ,EAAQF,EAAQG,MAAM,MACtBC,EAAQ,uCAAuCC,KAAKH,EAAM,IAC1DD,EAAc,KAAM,KACpBG,EAAO,KACLE,EAAWF,EAAM,GACjBZ,EAAQY,EAAM,GACdG,EAAOL,EAAMM,OAAS,EAAI,KAAO,GACjCC,EAAcP,EAAM,GAEtBD,EADEK,EACYf,EAAUe,GAAUd,EAAOE,GAChCa,EACW,KAAhBE,EACY,SAAUrB,UACfI,GAASJ,GAAUA,GAAUqB,GAGxBlB,EAAU,MAAMC,EAAOE,GAGzBH,EAAU,KAAKC,EAAOE,UAGjCO,EEUiBS,CAAeV,EAASN,GAChDK,EAAUY,YH9CG,SAAwBX,OACjCI,EAAQ,+EAA+EC,KACzFL,GAEEW,EAAc,KAAM,KACpBP,EAAO,KACLE,EAAWF,EAAM,GACjBZ,EAAQoB,WAAWR,EAAM,IACzBG,EAAOH,EAAM,GACbK,EAAcL,EAAM,GACpBE,EACFK,EAAcpB,EAAUe,GAAUd,GACzBe,EACW,KAAhBE,GACFA,EAAcG,WAAWH,GACzBE,EAAc,SAAUlB,UACfD,GAASC,GAAUA,GAAUgB,IAGtCE,EAAcpB,EAAU,MAAMC,GAGhCmB,EAAcpB,EAAU,KAAKC,UAG1BmB,EGqBiBE,CAAeb,GAGlC,SAASI,EAAMU,EAASC,EAAUC,MACnCD,EAASP,OAAQ,KACfS,GAAQ,MACP,IAAIC,EAAI,EAAGA,EAAIH,EAASP,OAAQU,OAGjCC,EAAeL,EAASC,EAASG,GAAI,KAChCH,EAASG,GAAGE,OACbL,EAASG,GAAGE,OAChB,IACkB,OAAdJ,SACK,EAETC,GAAQ,OACH,GAAkB,QAAdD,SACF,SAGJC,SAEF,EAGT,SAASE,EAAeL,EAASd,EAASqB,MACjB,iBAAZP,EAeJ,OAAId,EAAQsB,KAEbtB,EAAQsB,GAAGjC,KAAKgC,EAAKE,KAAK,SACnBT,IAMPd,EAAQwB,MAAQxB,EAAQwB,IAAInC,KAAKgC,EAAKE,KAAK,QAMnD,SAAqBT,EAASd,SACL,iBAAZc,EACFd,EAAQC,YAAYa,GACC,iBAAZA,GACTd,EAAQW,YAAYG,GARpBW,CAAYX,EAASd,MAzBxB0B,MAAMC,QAAQb,QACX,IAAII,EAAI,EAAGA,EAAIJ,EAAQN,OAAQU,OAC9BC,EAAeL,EAAQI,GAAIlB,EAASqB,UAC/B,WAIN,IAAIH,KAAKJ,EAAS,CACrBO,EAAKO,KAAKV,OACNW,EAAWV,EAAeL,EAAQI,GAAIlB,EAASqB,MACnDA,EAAKS,MACDD,EAAU,OAAO,YApGtB,SAAgBE,EAAOC,EAAU,QAClC7C,EAAS,IAET8C,MAAEA,GAAQ,EAAVjB,UAAiBA,EAAY,OAAUgB,EAEvCE,EAAQF,EAAQE,MAAQF,EAAQE,MAAQC,EAAAA,EAExCpB,EAAWiB,EAAQjB,UAAY,GAE/BrB,EAAcsC,EAAQI,cAAgB,GAAK,IACvB,iBAAbrB,IACTA,EDzBW,SAAuBA,OAChC5B,EAAS,GACTkD,GAAW,EACXC,GAAc,EACdC,EAAc,GACdC,EAAW,OACV,IAAItB,EAAI,EAAGA,EAAIH,EAASP,OAAQU,IAAK,KACpCuB,EAAU1B,EAAS2B,OAAOxB,MAC1BmB,MACe,MAAbG,EAAkB,IAEJ,MAAZC,EAAiB,CACnBD,EAAW,YAIbD,EAAYT,MACZO,GAAW,EACXnB,aAGFqB,EAAYX,KAAKa,GACjBD,EAAWC,UAGTH,EAAa,IAEXzC,EAAWR,KAAKoD,GAAU,CAC5BD,EAAWC,WAGbH,GAAc,EAGA,MAAZG,EAMA5C,EAAWR,KAAKoD,IACdF,EAAY/B,QAAQrB,EAAOyC,KAAKW,EAAYhB,KAAK,KACrDgB,EAAc,GACdD,GAAc,IAGhBC,EAAYX,KAAKa,GACjBD,EAAW,KAZTH,GAAW,EACXG,EAAW,WAcE,MAAbA,GAAkBD,EAAYT,MAC9BS,EAAY/B,QAAQrB,EAAOyC,KAAKW,EAAYhB,KAAK,KAE9CpC,EC5BMwD,CAAc5B,IAE3BA,EAAWA,EAAS6B,KAAI,SAAU5C,OAC5BD,EAAY,CACduB,IAAI,EACJE,KAAK,EACLJ,QAAQ,EACRyB,cAAUjE,GAGc,MAAtBoB,EAAQ0C,OAAO,KACjB3C,EAAUqB,QAAS,EACnBpB,EAAUA,EAAQ8C,UAAU,QAE1BC,EAAQ/C,EAAQgD,QAAQ,QACxBD,GAAS,EAAG,KACVhE,EAAQiB,EAAQ8C,UAAUC,EAAQ,MAClCA,EAAQ,EAAG,KACTvB,EAAMxB,EAAQ8C,UAAU,EAAGC,GACnB,OAARvB,IAEFzB,EAAUuB,GAAK,IAAIxD,OAChB,UAAS6B,EAAaZ,YACvBW,IAGJK,EAAUyB,IAAM,IAAI1D,OACjB,UAAS6B,EAAa6B,YACvB9B,GAGJI,EAAcC,EAAWhB,EAAOW,QAEhCI,EAAcC,EAAWC,EAASN,UAG7BK,SAGLkD,EAAU,MACT,IAAI/B,EAAI,EAAGA,EAAIa,EAAMvB,QAAUyC,EAAUf,EAAOhB,IAC/Cd,EAAM2B,EAAMb,GAAIH,EAAUC,KAC5BiC,EAAU9D,EAAOyC,KAAKK,EAAQf,EAAIa,EAAMb,YAGrC/B"}